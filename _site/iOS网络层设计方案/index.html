<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>网络层设计方案 &#8211; xf's bolg</title>
<meta name="description" content="Sample post with a background image CSS override.">
<meta name="keywords" content="sample post">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="网络层设计方案">
<meta property="og:description" content="Sample post with a background image CSS override.">
<meta property="og:url" content="http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/">
<meta property="og:site_name" content="xf's bolg">





<link rel="canonical" href="http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="xf's bolg Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(http://localhost:4000/images/triangular.png);}</style>


</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar1.jpeg" alt="xiaofei zhou photo" class="author-photo">
					<h4>xiaofei zhou</h4>
					<p>慧行坚勇,究畅恒无极</p>
				</li>
				<li><a href="http://localhost:4000/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:zhouxiaofei0001@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="http://localhost:4000/theme-setup/" >Theme Setup</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">External Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" rel="bookmark" title="网络层设计方案">网络层设计方案</a></h1>
        
        <h2><span class="entry-date date published"><time datetime="2018-12-11T00:00:00-05:00">December 11, 2018</time></span></h2>
        
        <p class="entry-reading-time">
          <i class="fa fa-clock-o"></i>
          
Reading time ~2 minutes
        </p><!-- /.entry-reading-time -->
        
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <p>#网络层设计方案
<a href="http://www.cocoachina.com/ios/20150603/12023.html">原文地址</a></p>

<h2 id="前言">前言</h2>
<p>主要以下方面</p>

<ul>
  <li>网络层跟业务对接部分设计</li>
  <li>网络层安全机制实现</li>
  <li>网络层的优化方案</li>
</ul>

<h2 id="网络层跟业务对接部分的设计">网络层跟业务对接部分的设计</h2>

<h3 id="使用哪种方式跟业务层对接">使用哪种方式跟业务层对接?</h3>

<ul>
  <li>以什么方式将数据交付给业务层</li>
  <li>交付什么样的数据给业务层</li>
</ul>

<h4 id="以什么方式交付">以什么方式交付</h4>

<ul>
  <li>Block</li>
  <li>Delegate</li>
  <li>Notification</li>
  <li>KVO</li>
  <li>Target-Action</li>
</ul>

<p>作者意见: delegate</p>

<ol>
  <li>尽可能减少跨层数据交流的可能,限制耦合</li>
  <li>统一回调方法,便于测试和维护</li>
  <li>在跟业务层对接的部分只采用一种对接手段,限制灵活性,以此来交换应用的可维护性</li>
</ol>

<h5 id="尽可能减少跨层数据交流的可能限制耦合">尽可能减少跨层数据交流的可能,限制耦合</h5>
<p>例如,数据流向为 A&gt;B&gt;C ,但是需要A层去处理C层的数据,就会出现问题,比如说网络状态变化这个问题</p>

<p><strong>为什么不适用block</strong></p>

<ol>
  <li>延长对象的生命周期,如果网络请求尚未结束便退出了控制器,便会有内存泄露的危险,delegate是弱引用,控制器回收,delegate就回收了</li>
  <li>统一回调方法,便于调试和维护</li>
</ol>

<h5 id="交付什么样的数据给业务层">交付什么样的数据给业务层</h5>

<p>直接转换成model类型,可以提高代码的客服性,但是这部分转换成本有点高</p>

<ol>
  <li>数组内容转换成本高</li>
  <li>转换之后的数据大部分是不能直接使用的,为了能被展示,还需要二次转换</li>
  <li>只有在api返回高度标准化的时候,这些model的复用程度才高</li>
  <li>调试的时候通过对象原型查看数据内容不如dictionary或者array只管</li>
  <li>同意api数据被不同的view展示的时候,难以控制数据转换的代码,有可能会散落在各个地方</li>
</ol>

<h6 id="解决方案">解决方案:</h6>
<p>添加一个reformer层,这个对象用于封装数据转换的逻辑,这是一个独立对象,事实上,是作为Adaptor模式存在的,需要用到什么样的数据,就转换成什么样的数据</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">先定义一个</span><span class="n">protocol</span><span class="err">：</span>
<span class="k">@protocol</span><span class="err"> </span><span class="nc">ReformerProtocol</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="p">(</span><span class="n">NSDictionary</span><span class="p">)</span><span class="n">reformDataWithManager</span><span class="o">:</span><span class="p">(</span><span class="n">APIManager</span><span class="err"> </span><span class="o">*</span><span class="p">)</span><span class="n">manager</span><span class="p">;</span>
<span class="k">@end</span>
<span class="err">在</span><span class="n">Controller</span><span class="err">里是这样：</span>
<span class="k">@property</span><span class="err"> </span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="err"> </span><span class="n">strong</span><span class="p">)</span><span class="err"> </span><span class="n">idXXXReformer</span><span class="p">;</span>
<span class="k">@property</span><span class="err"> </span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="err"> </span><span class="n">strong</span><span class="p">)</span><span class="err"> </span><span class="n">idYYYReformer</span><span class="p">;</span>
<span class="cp">#pragma mark - APIManagerDelegate
</span><span class="o">-</span><span class="err"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">apiManagerDidSuccess</span><span class="o">:</span><span class="p">(</span><span class="n">APIManager</span><span class="err"> </span><span class="o">*</span><span class="p">)</span><span class="n">manager</span>
<span class="p">{</span>
<span class="err">    </span><span class="n">NSDictionary</span><span class="err"> </span><span class="o">*</span><span class="n">reformedXXXData</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="p">[</span><span class="n">manager</span><span class="err"> </span><span class="nf">fetchDataWithReformer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">XXXReformer</span><span class="p">];</span>
<span class="err">    </span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">XXXView</span><span class="err"> </span><span class="nf">configWithData</span><span class="p">:</span><span class="n">reformedXXXData</span><span class="p">];</span>
<span class="err">    </span><span class="n">NSDictionary</span><span class="err"> </span><span class="o">*</span><span class="n">reformedYYYData</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="p">[</span><span class="n">manager</span><span class="err"> </span><span class="nf">fetchDataWithReformer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">YYYReformer</span><span class="p">];</span>
<span class="err">    </span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">YYYView</span><span class="err"> </span><span class="nf">configWithData</span><span class="p">:</span><span class="n">reformedYYYData</span><span class="p">];</span>
<span class="p">}</span>
<span class="err">在</span><span class="n">APIManager</span><span class="err">里面，</span><span class="n">fetchDataWithReformer</span><span class="err">是这样：</span>
<span class="o">-</span><span class="err"> </span><span class="p">(</span><span class="n">NSDictionary</span><span class="p">)</span><span class="n">fetchDataWithReformer</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">reformer</span>
<span class="p">{</span>
<span class="err">    </span><span class="k">if</span><span class="err"> </span><span class="p">(</span><span class="n">reformer</span><span class="err"> </span><span class="o">==</span><span class="err"> </span><span class="nb">nil</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
<span class="err">        </span><span class="k">return</span><span class="err"> </span><span class="n">self</span><span class="p">.</span><span class="n">rawData</span><span class="p">;</span>
<span class="err">    </span><span class="p">}</span><span class="err"> </span><span class="k">else</span><span class="err"> </span><span class="p">{</span>
<span class="err">        </span><span class="k">return</span><span class="err"> </span><span class="p">[</span><span class="n">reformer</span><span class="err"> </span><span class="nf">reformDataWithManager</span><span class="p">:</span><span class="n">self</span><span class="p">];</span>
<span class="err">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>要点</p>

  <ul>
    <li>reformer 是一个符合ReformerProtocol的对象,提供了方法供Manager使用</li>
    <li>Api的原始数据(JSON)由Manager实例保管,reformer方法里面取Managfer的原始数据去做转换,然后交付出去,</li>
    <li>例子中句的是一个Api数据被多个View使用的情况,提现了reformer的一个特点: 可以根据需要改变同意数据来源的展示方式</li>
    <li>在同一个View里展示不同API数据的情况,reformer是绝佳工具</li>
  </ul>
</blockquote>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">apiManagerDidSuccess</span><span class="p">:(</span><span class="n">APIManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">manager</span>
<span class="p">{</span>
    <span class="c1">// 这个回调方法有可能是来自二手房列表APIManager的回调，也有可能是租房，也有可能是新房。但是在Controller层面我们不需要对它做额外区分，只要是同一个reformer出来的数据，我们就能保证是一定能被self.XXXView使用的。这样的保证由reformer的实现者来提供。</span>
    <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">reformedXXXData</span> <span class="o">=</span> <span class="p">[</span><span class="n">manager</span> <span class="nf">fetchDataWithReformer</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">XXXReformer</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">XXXView</span> <span class="nf">configWithData</span><span class="p">:</span><span class="n">reformedXXXData</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <ul>
    <li>简化controller代码,数据原型在这种情况下也不需要存在了,随之而来的 成本就省去了</li>
  </ul>
</blockquote>

<blockquote>
  <p>好处</p>

  <ol>
    <li>绕开了API数据原型的转换,避免了相关成本</li>
    <li>在处理单独View多API,单API多View的时候,非常好用</li>
    <li>转换逻辑中,转换次数限制为只有一次</li>
    <li>controller省去很多代码</li>
    <li>业务数据和业务有了适当的隔离,这样,如果业务逻辑有修改,滑进一个reformer,就好了,如果其他业务有想同的转化逻辑,直接可以复用</li>
  </ol>
</blockquote>

<h5 id="在不适用特定对象表征数据的情况下如何保持数据可读性">在不适用特定对象表征数据的情况下,如何保持数据可读性?</h5>

<p><em>使用固定字符串做key</em></p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertyListReformerKeys</span><span class="p">.</span><span class="n">h</span>
<span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyID</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyName</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyTitle</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyImage</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertyListReformer</span><span class="p">.</span><span class="n">h</span>
<span class="cp">#import "PropertyListReformerKeys.h"
</span><span class="p">...</span> <span class="p">...</span>
</code></pre></div></div>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertyListReformer</span><span class="p">.</span><span class="n">m</span>
<span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyID</span> <span class="o">=</span> <span class="s">@"kPropertyListDataKeyID"</span><span class="p">;</span>
<span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyName</span> <span class="o">=</span> <span class="s">@"kPropertyListDataKeyName"</span><span class="p">;</span>
<span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyTitle</span> <span class="o">=</span> <span class="s">@"kPropertyListDataKeyTitle"</span><span class="p">;</span>
<span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kPropertyListDataKeyImage</span> <span class="o">=</span> <span class="s">@"kPropertyListDataKeyImage"</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">reformData</span><span class="p">:(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">originData</span> <span class="nf">fromManager</span><span class="p">:(</span><span class="n">APIManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">manager</span>
<span class="p">{</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="p">...</span> <span class="p">...</span>
    <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">resultData</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">manager</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">ZuFangListAPIManager</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
        <span class="n">resultData</span> <span class="o">=</span> <span class="p">@{</span>
            <span class="nl">kPropertyListDataKeyID:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"id"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyName:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"name"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyTitle:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"title"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithUrlString</span><span class="p">:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"imageUrl"</span><span class="p">]]</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">manager</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">XinFangListAPIManager</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
        <span class="n">resultData</span> <span class="o">=</span> <span class="p">@{</span>
            <span class="nl">kPropertyListDataKeyID:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"xinfang_id"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyName:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"xinfang_name"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyTitle:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"xinfang_title"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithUrlString</span><span class="p">:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"xinfang_imageUrl"</span><span class="p">]]</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">manager</span> <span class="nf">isKindOfClass</span><span class="p">:[</span><span class="n">ErShouFangListAPIManager</span> <span class="nf">class</span><span class="p">]])</span> <span class="p">{</span>
        <span class="n">resultData</span> <span class="o">=</span> <span class="p">@{</span>
            <span class="nl">kPropertyListDataKeyID:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"esf_id"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyName:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"esf_name"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyTitle:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"esf_title"</span><span class="p">],</span>
            <span class="nl">kPropertyListDataKeyImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nf">imageWithUrlString</span><span class="p">:</span><span class="n">originData</span><span class="p">[</span><span class="s">@"esf_imageUrl"</span><span class="p">]]</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">resultData</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PropertListCell</span><span class="p">.</span><span class="n">m</span>
<span class="cp">#import "PropertyListReformerKeys.h"
</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">configWithData</span><span class="o">:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span>
<span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nf">kPropertyListDataKeyImage</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">idLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nf">kPropertyListDataKeyID</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nf">kPropertyListDataKeyName</span><span class="p">];</span>
    <span class="n">self</span><span class="p">.</span><span class="n">titleLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nf">kPropertyListDataKeyTitle</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>图</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">----------------------------------</span>          <span class="o">-----------------------------------------</span>
    <span class="o">|</span>                                <span class="o">|</span>          <span class="o">|</span>                                       <span class="o">|</span>
    <span class="o">|</span> <span class="n">PropertyListReformer</span><span class="p">.</span><span class="n">m</span>         <span class="o">|</span>          <span class="o">|</span> <span class="n">PropertyListReformer</span><span class="p">.</span><span class="n">h</span>                <span class="o">|</span>
    <span class="o">|</span>                                <span class="o">|</span>          <span class="o">|</span>                                       <span class="o">|</span>
    <span class="o">|</span> <span class="err">#</span><span class="n">import</span> <span class="n">PropertyListReformer</span><span class="p">.</span><span class="n">h</span> <span class="o">|</span> <span class="o">&lt;-------</span> <span class="o">|</span>  <span class="err">#</span><span class="n">import</span> <span class="s">"PropertyListReformerKeys.h"</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">key</span> <span class="o">=</span> <span class="s">@"key"</span>  <span class="o">|</span>          <span class="o">|</span>                                       <span class="o">|</span>
    <span class="o">|</span>                                <span class="o">|</span>          <span class="o">|</span>                                       <span class="o">|</span>
    <span class="o">----------------------------------</span>          <span class="o">-----------------------------------------</span>
                                                                    <span class="p">.</span>
                                                                   <span class="o">/|</span>\
                                                                    <span class="o">|</span>
                                                                    <span class="o">|</span>
                                                                    <span class="o">|</span>
                                                                    <span class="o">|</span>
                                                    <span class="o">---------------------------------</span>
                                                    <span class="o">|</span>                               <span class="o">|</span>
                                                    <span class="o">|</span> <span class="n">PropertyListReformerKeys</span><span class="p">.</span><span class="n">h</span>    <span class="o">|</span>
                                                    <span class="o">|</span>                               <span class="o">|</span>
                                                    <span class="o">|</span> <span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">key</span><span class="p">;</span>  <span class="o">|</span>
                                                    <span class="o">|</span>                               <span class="o">|</span>
                                                    <span class="o">---------------------------------</span>
</code></pre></div></div>

<p>字符串的声明直接放在独立的头文件,直接导入头文件即可</p>

<ul>
  <li>要注意命名规范</li>
</ul>

<blockquote>
  <p>###总结<br />
对于业务层而言,有controller根据View和ApiManager直接的关系,选择合适的reformer可以直接使用的数据,转换好之后直接交付给View,对于网络层而言,只需要保持住原始数据即可,不需要主动转换成数据原型,然后采用Dictionary 加 Const字符串key来表征,避免了使用对象来表征带来的迁移困难,同时不失去可读性</p>
</blockquote>

<h5 id="集约型api和离散型api调用方式的选择-">集约型API和离散型API调用方式的选择 ?</h5>
<p>集约型的意思就是,所有的API调用只有一个类,然后这个类接受API名字.api参数,以及回调着陆点,作为参数,然后执行startRequest类似的方法<br />
离散型api调用是这样的,一个apiManager对应一个API,然后这个APIManager只需要参数就能起飞.其他的数据比如请求方法,回调方法等,都已经集成进了APIManager中</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">离散型</span><span class="n">API</span><span class="err">调用方式：</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">ItemListAPIManager</span> <span class="o">*</span><span class="n">itemListAPIManager</span><span class="p">;</span>
<span class="c1">// getter</span>
<span class="k">-</span> <span class="p">(</span><span class="n">ItemListAPIManager</span> <span class="o">*</span><span class="p">)</span><span class="n">itemListAPIManager</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_itemListAPIManager</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_itemListAPIManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ItemListAPIManager</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>
        <span class="n">_itemListAPIManager</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_itemListAPIManager</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 使用的时候就这么写：</span>
<span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">itemListAPIManager</span> <span class="nf">loadDataWithParams</span><span class="p">:</span><span class="n">params</span><span class="p">];</span>
</code></pre></div></div>

<p>这两种方法在下层都是集约型的调用方式,不建议在业务层的代码直接使用集约型的API调用方式,原因如下</p>

<ol>
  <li>当前请求正在进行的时候,根据不同的业务需求存在两种不同的请求策略,一个是取消新发送的请求,等待旧的请求完成,另一种是取消旧的请求,直接开始新的请求; 集约化的请求方式如果要满足这样的需求,那么每次请求的时候都要多谢一部分判断和取消的代码.手段就做不到很干净</li>
  <li>针对某个API请求来进行AOP,在集约型的API调用方式下,如果要针对某个API请求的发起和完成过程进行AOP,很难的实现</li>
  <li>当API请求的着陆点小时的时候,离散型的api调用能更加透明的处理这种情况
 如果正在请求的时候用户点击返回按钮,集约型的调用方式需要把取消当前页面所有请求的业务放在dealloc中,而离散型的直接写到APImanager中就行了,因为控制器呗回收之后,APIMAnager也一起被回收了,不需要要担心这个问题了</li>
  <li>离散型的API调用方式能最大程度的给业务提供灵活性,比如,如果是基于分页的数据,name可以直接在apiManager中使用loadNextPage方便做到.不需要业务放去管理页码了,如果针对业务请求参数进行验证,比如填写注册信息,在离散型的APIManager里面实现就会非常轻松</li>
</ol>

<h6 id="怎么做apimanager的继承">怎么做APIManager的继承</h6>

<p>如果要做成离散型的API调用,那么使用继承是逃不掉的.BaseApiMAnager负责集约化的部分,在里面采用集约化的手段组装请求,发起请求,然而业务方调用API的时候,则是以离散的API调用方式来调用</p>

<p>一般的思路是BaseApiManager提供一些空方法来给子类做重载,然而我的建议是,不要这么做,我们可以用IOP的方式来限制派生类的重载</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BaseAPIManager</span><span class="err">的</span><span class="n">init</span><span class="err">方法里这么写：</span>
<span class="c1">// 注意是weak。</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">idchild</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">init</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="nf">confirmToProtocol</span><span class="p">:</span><span class="k">@protocol</span><span class="err">(</span><span class="nc">APIManager</span><span class="p">)])</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 不遵守这个protocol的就让他crash，防止派生类乱来。</span>
        <span class="n">NSAssert</span><span class="p">(</span><span class="nb">NO</span><span class="p">,</span> <span class="s">"子类必须要实现APIManager这个protocol。"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">protocol</span><span class="err">这么写，把原本要重载的函数都定义在这个</span><span class="n">protocol</span><span class="err">里面，就不用在父类里面写空方法了：</span>
<span class="k">@protocol</span> <span class="nc">APIManager</span>
<span class="err">@required</span>
<span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">apiMethodName</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">@end</span>
<span class="err">然后在父类里面如果要使用的话，就这么写：</span>
<span class="p">[</span><span class="n">self</span> <span class="nf">requestWithAPIName</span><span class="p">:[</span><span class="n">self</span><span class="p">.</span><span class="n">child</span> <span class="nf">apiMethodName</span><span class="p">]</span> <span class="p">......];</span>
</code></pre></div></div>

<p>简单来说就是在init的时候检查自己是否符合预先设计的子类的protocol,这就要求所有的子类都必须遵守这个protocol,所有针对父类的重载,覆盖也都是以这个protocol为准,prototocl的方法都不允许重载,覆盖,在父类的代码里面,可以不必遵守这个protocol,保持了未来维护的灵活性.</p>

<p>这么做的好处就是避免了父类的控方法,同时也给子类戴上了紧箍咒.</p>

<blockquote>
  <p>###要点总结</p>
  <ol>
    <li>使用delegate来做数据对接,近在必要的时候来做跨层访问</li>
    <li>交付NSDictionary给业务层,使用 Const字符串来保持可持续性</li>
    <li>提供reformer机制来处理网络层反馈的数据,这个机制很重要,好处几多</li>
    <li>网络层上部分使用离散型设计,下部分使用集约型设计</li>
    <li>设计合理的继承机制,让派生出来的APIManager收到限制,避免混乱</li>
  </ol>
</blockquote>

<h2 id="网络层的安全机制">网络层的安全机制</h2>

<p>使用这个机制的目的主要有两点</p>

<ol>
  <li>确保API来自你自己的API</li>
  <li>防止竞争对手爬你的API</li>
</ol>

<h3 id="确保api来自自己的app">确保API来自自己的APP</h3>
<p>解决方案: 设计签名</p>

<h3 id="保证数据传输的安全">保证数据传输的安全</h3>
<p>解决方案: HTTPS</p>

<h3 id="安全机制小总结">安全机制小总结</h3>

<ul>
  <li>针对链接建立环节的优化</li>
  <li>针对链接传输 数据量的优化</li>
  <li>针对链接复用的优化</li>
</ul>

<h4 id="1-针对链接建立环节的优化">1. 针对链接建立环节的优化</h4>
<p>在API发起请求建立连接的环节,大致会分下面这些步骤</p>

<ol>
  <li>发起请求</li>
  <li>DNS域名解析得到IP</li>
  <li>根据IP进行三次握手(HTTPS四次),连接建立成功</li>
</ol>

<h5 id="11-针对发起请求的优化手段">1.1 针对发起请求的优化手段</h5>

<h6 id="111-使用缓存手段减少请求的发起次数">1.1.1 使用缓存手段减少请求的发起次数</h6>
<p>需要注意的是缓存的清除实际</p>
<h6 id="112-使用策略减少请求的发起次数">1.1.2 使用策略减少请求的发起次数</h6>
<p>比如说下拉刷新的时候,重复的请求就可以不必发送了,另外一种就是根据策略进行请求</p>

<h6 id="113-针对dns域名解析做优化以及建立连接的优化">1.1.3 针对DNS域名解析做优化,以及建立连接的优化</h6>
<p><a href="https://github.com/mattt/NSEtcHosts">看这个MAtt大神的工具</a></p>

<h6 id="114-针对链接传输数据量的优化">1.1.4 针对链接传输数据量的优化</h6>
<p>压缩数据</p>
<h6 id="115">1.1.5</h6>
<p>针对链接复用的优化</p>

      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/#sample post" title="Pages tagged sample post" class="tag"><span class="term">sample post</span></a></span>
        
        <div class="social-share">
  <ul class="socialcount socialcount-small inline-list">
    <li class="facebook"><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="Share on Facebook"><span class="count"><i class="fa fa-facebook-square"></i> Like</span></a></li>
    <li class="twitter"><a href="https://twitter.com/intent/tweet?text=http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="Share on Twitter"><span class="count"><i class="fa fa-twitter-square"></i> Tweet</span></a></li>
    <li class="googleplus"><a href="https://plus.google.com/share?url=http://localhost:4000/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="Share on Google Plus"><span class="count"><i class="fa fa-google-plus-square"></i> +1</span></a></li>
  </ul>
</div><!-- /.social-share -->
      </footer>
    </div><!-- /.entry-content -->
    
    <div class="read-more">
  
    <div class="read-more-header">
      <a href="http://localhost:4000/background-image/" class="read-more-btn">Read More</a>
    </div><!-- /.read-more-header -->
    <div class="read-more-content">
      <h3><a href="http://localhost:4000/background-image/" title="Post with a Background Image">Post with a Background Image</a></h3>
      <p>Sample post with a background image CSS override. <a href="http://localhost:4000/background-image/">Continue reading</a></p>
    </div><!-- /.read-more-content -->
  
  <div class="read-more-list">
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/code-highlighting-post/" title="Syntax Highlighting Post">Syntax Highlighting Post</a></h4>
        <span>Published on August 16, 2013</span>
      </div><!-- /.list-item -->
    
      <div class="list-item">
        <h4><a href="http://localhost:4000/sample-link-post/" title="Sample Link Post">Sample Link Post</a></h4>
        <span>Published on August 12, 2013</span>
      </div><!-- /.list-item -->
    
  </div><!-- /.read-more-list -->
</div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2019 xiaofei zhou. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>



	        

</body>
</html>
