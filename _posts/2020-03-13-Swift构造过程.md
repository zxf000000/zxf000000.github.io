---
layout: post
title: Swift 构造过程
tags:
  - iOS
---

## 存储属性的初始赋值

类和结构体在初始化时,必须为所有存储属性赋值, 不能让存储属性处在一个未知的状态.   

两种方法:    

### 构造器  

即 ``init()`` 方法, 最简单的构造器   

* 默认构造器
* 自定义构造器

### 默认值

可以再声明属性的时候直接给属性赋值, 也可以咋构造器中为属性赋值   

```swift
class Foo {
	let bar = 32.0
}
```

### 自定义构造过程

可以通过输入形参和可选类型属性自定义构造过程,  可以在构造过程中分配常量属性

#### 形参的构造过程

```
class Foo {
	let green, blue, red : Double
	init(red: Double, blue: Double, green: Double) {
		red = 10.0
		blue = 10.0
		green = 10.0
	}
}
```
如果方法没有声明实参标签,那么Swift会为每个构造器的形参生成一个实参标签 (在其他方法中这条也适用)

#### 不带实参的构造器

如果不希望构造器使用实参标签, 可以用下划线_代替, 这样在调用的时候就不需要输入实参标签

#### 可选属性类型

使用 ? 放在末尾表示不确定这个变量/常量是什么情况, 在构造阶段会自动赋值为nil

```
class Foo {
    var bar: Double?
    let qu: Double
    init(_ qu: Double) {
        self.qu = qu
    }
}
```

#### 常量属性赋值

可以在构造过程的任意时间点给常量属性赋值, 但是在构造结束之后必须确保常量属性赋值完毕


### 默认构造器

结构体或者类没有指定构造器的时候, Swift会自动生成一个所有值都为默认值的简单构造器    
结构体如果没有构造器,会生成一个逐一成员构造器   

```swift
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
```
使用逐一成员构造器的时候, 可以省略任意有默认值的属性

### 代理构造器

结构体的代理构造器, 代表一个构造器可以调用其他构造器生成本实体的实例,然后进行赋值等其他操作

### 类的集成和构造过程

类里面的所有属性, 包括存储属性和集成自父类的属性, 都必须在构造过程中设置初始值   

Swift为类提供了两种构造器保证上一过程, 指定构造器和便利构造器  

#### 指定构造器

类里面最重要的构造器  ,  通过指定构造器初始化类里面所有属性, 并且调用合适的父类构造器让构造过程沿着父类的指定构造器网上走.   

每一个类必须拥有至少一个指定构造器, 可以指定任意便利构造器, 但是便利构造器必须调用指定构造器   

指定构造器与简单构造器的写法相同   

便利构造器需要在 init 前面加关键词 convenience

```
convenience init(parameters) {
    statements
}
```

#### 类的构造器代理

必须遵循以下原则

* 指定构造器必须调用其直接父类的指定构造器
* 便利构造器必须调用同类中定义的其他构造器
* 便利构造器最后必须调用指定构造器

>> * 便利构造器必须总是横向代理
>> * 指定构造器必须总是向上代理  


图示:  
![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsnw5jvmsj30jc08qt9n.jpg)

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsnwtlsxjj30i50i2myw.jpg)


#### 两段式构造过程

1. 类中每一个存储属性设置一个初始值, 所有属性设置完毕之后开始第二阶段
2. 给每个类一次机会, 在新实例开始使用之前进一步设置属性或者其他

编译器将进行4个安全检查,确保构造过程不会出问题  

1. 指定构造器必须在向上代理之前完成所有属性的初始化/设置初始值
2. 指定构造器在为继承的属性设置新值的时候必须调用父类的指定构造器, 否则设置的新值会被父类的指定构造器覆盖
3. 便利构造器在为任意属性赋值之前必须调用指定构造器, 否则设置的新值会被指定构造器覆盖
4. 构造器在完成构造过程之前不能调用任何实例方法, 不能调用任意属性的值, 不能引用``self `` 作为一个值

类的实例在第一阶段并不是完全有效的, 只有在完成第一阶段之后类的实例才是有效的, 才能访问属性和实例方法    


以下是两段式构造过程: 

##### 阶段1

* 类的某个指定构造器或者便利构造器呗调用
* 完成新实例的内存分配, 但此时内存还没有初始化
* 指定构造器确保其所有引入的类型都已设置初值, 存储类型所属的内存初始化
* 指定构造器切换到父类构造器, 对其完成同样的事情
* 这个过程沿着类的继承链一直往上执行, 直到类的最顶部
* 到达继承链的最顶部, 直到确保所有的存储类型都已初始化,  这个实例的内存被认为已经初始化,阶段1 完成

##### 阶段2 

* 从继承链往下,每个类有机会自定义实例, 可以访问实例方法,属性和self实例
* 最终, 继承链的任意便利构造方法均可以调用self. 实例方法和自定义实例

构造阶段1: 

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsokndzqij30jv086t9a.jpg)

构造阶段2: 

![](https://tva1.sinaimg.cn/large/00831rSTgy1gcsol0x2vbj30la09m3z5.jpg)

### 构造器的继承和重写

Swift 类默认情况下不会继承父类的构造器   

可以防止一个父类的简单构造器呗一个子类的更精细的构造器继承,

可以重写父类的构造器, 前面需要加上  override   

因为子类的任何构造器都不能调用父类的便利构造器, 所以严格来讲,子类不能重写父类的便利构造器, 所以 "重写" 父类的便利构造器的时候 不需要加 ``override``  

#### 构造器的自动继承

* 如果子类没有定义任何指定构造器, 那么会自动继承父类所有的指定构造器
* 如果子类提供了所有父类指定构造器的实现, (规则一适用), 那么将继承父类所有的便利构造器

## 可失败构造器

枚举和结构体类型可以构建可失败构造器 ---- init后面加上?  ``init?``
然后在传入参数不符合要求的时候,可以``return nil``, 代表构造失败

```swift
enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .Kelvin
        case "C":
            self = .Celsius
        case "F":
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
```

### 可失败构造器的传递

可失败构造器可以任意横向,纵向代理, 亦可代理到不可失败构造器   

子类可以重写父类的可失败构造器, 亦可将父类的可失败构造器重写为不可失败构造器, 需要对父类构造器的结果强制解包  

## 必要构造器

在构造器前面加上 ``require`` 表示所有子类必须重写本构造器, 重写必要构造器时, 不需要加上 ``override`` 关键字




